#ifndef MARS_H
#define MARS_H

#include <QObject>
#include <QThread>
#include "igame.h"
#include "animsequence.h"
#include <map>
#include <string>
#include <list>
#include <deque>
#include <glm/glm.hpp>

// The Codegen's Parser
#include "parser/parser.h"
#include "parser/structures.h"

using namespace std;

namespace visualizer
{
	struct Rect
	{
		int left;
		int top;
		int right;
		int bottom;
	};

    class Mars: public QThread, public AnimSequence, public IGame
    {
        Q_OBJECT;
        Q_INTERFACES( visualizer::IGame );
        private:
			struct Game
			{
                struct Animatable
                {
                    Animatable(const parser::GameState& state, const int& id)
                    {
                        if(state.animations.find(id) != state.animations.end())
                            m_Animations = state.animations.at(id);
                    }

                    std::vector<SmartPointer<parser::Animation> > m_Animations;
                };

                struct Unit : public parser::Unit, public Animatable
                {
                    Unit(const parser::GameState& state, const parser::Unit& unit) :
                        parser::Unit(unit),
                        Animatable(state, unit.id)
                        {}
                };

                struct Tile : public parser::Tile, public Animatable
                {
                    Tile(const parser::GameState& state, const parser::Tile& tile) :
                        parser::Tile(tile),
                        Animatable(state, tile.id)
                        {}
                };

				struct State
				{
                    std::map<int, SmartPointer<parser::Player> > players;
                    std::map<int, SmartPointer<Unit> > units;
                    std::map<int, SmartPointer<Tile> > tiles;
                    std::vector<std::vector< SmartPointer<Tile> > > tileGrid;
					int playerID;
					int turnNumber;
				};

				Game(parser::Game* game);

				int mapWidth;
			    int mapHeight;
			    int maxHealth;
			    int trenchDamage;
			    int waterDamage;
			    int attackDamage;
			    int offensePower;
			    int defensePower;
			    int maxUnits;
			    int unitCost;
			    int gameNumber;
			    int winner;
			    std::string winReason;

			  	std::vector<State> states;
			};

        public:
            Mars();
            ~Mars();

            PluginInfo getPluginInfo();
            void loadGamelog( std::string gamelog );

            void run();
            void setup();
            void destroy();

            void preDraw();
            void postDraw();

            void addCurrentBoard();

            map<string, int> programs;

            list<int> getSelectedUnits();

            list<std::string> getDebugOptions();

        private:
            Game *m_game;  // The Game Object from parser/structures.h that is generated by the Codegen
            bool m_suicide;

			list<int> m_selectedUnitIDs;

			void RenderWorld(int state, std::deque<glm::ivec2>& trail, vector<vector<int>>& turnMap, Frame& turn);

			void ProccessInput();

			void GetSelectedRect(Rect& out) const;

            void drawGrid();
			void drawObjectSelection() const;
            void drawBoxAroundObj(const SmartPointer<parser::Mappable> obj, const glm::vec4& color) const;

            void drawQuadAroundObj(const SmartPointer<parser::Mappable> obj, const glm::vec4& color) const;

			template< class T >
			bool drawQuadAroundObj(const T& datastruct, const typename T::key_type& key) const
			{
			  auto iter = datastruct.find(key);

			  if(iter != datastruct.end())
			  {
				const auto& obj = iter->second;

				renderer->setColor( Color( 1.0, 0.4, 0.4, 0.6 ) );
				renderer->drawQuad(obj.x,obj.y,1,1);
				return true;
			  }

			  return false;
			}
    };

} // visualizer

#endif // MARS_H
